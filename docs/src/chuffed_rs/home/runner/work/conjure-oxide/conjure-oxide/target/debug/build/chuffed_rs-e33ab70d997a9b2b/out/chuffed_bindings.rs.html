<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/conjure-oxide/conjure-oxide/target/debug/build/chuffed_rs-e33ab70d997a9b2b/out/chuffed_bindings.rs`."><title>chuffed_bindings.rs - source</title><script> if (window.location.protocol !== "file:") document.write(`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2">`)</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="chuffed_rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0-nightly (1684a753d 2024-04-01)" data-channel="nightly" data-search-js="search-42d8da7a6b9792c2.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-12cf3b4f4f9dc36d.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title">
            <h2>Files</h2></div></nav><div class="sidebar-resizer"></div>
    <main><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../../../../../../../../../../chuffed_rs/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../../../../../../../../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../../../../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../../../../../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
</pre></div><pre class="rust"><code><span class="comment">/* automatically generated by rust-bindgen 0.69.4 */

</span># [repr (C)] # [derive (Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub struct </span>__BindgenBitfieldUnit &lt; Storage &gt; { storage : Storage , } <span class="kw">impl </span>&lt; Storage &gt; __BindgenBitfieldUnit &lt; Storage &gt; { # [inline] <span class="kw">pub const fn </span>new (storage : Storage) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ storage } } } <span class="kw">impl </span>&lt; Storage &gt; __BindgenBitfieldUnit &lt; Storage &gt; <span class="kw">where </span>Storage : AsRef &lt; [u8] &gt; + AsMut &lt; [u8] &gt;, { # [inline] <span class="kw">pub fn </span>get_bit (&amp; <span class="self">self </span>, index : usize) -&gt; bool { debug_assert ! (index / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span>byte_index = index / <span class="number">8 </span>; <span class="kw">let </span>byte = <span class="self">self </span>. storage . as_ref () [byte_index] ; <span class="kw">let </span>bit_index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { <span class="number">7 </span>- (index % <span class="number">8</span>) } <span class="kw">else </span>{ index % <span class="number">8 </span>} ; <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; bit_index ; byte &amp; mask == mask } # [inline] <span class="kw">pub fn </span>set_bit (&amp; <span class="kw-2">mut </span><span class="self">self </span>, index : usize , val : bool) { debug_assert ! (index / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span>byte_index = index / <span class="number">8 </span>; <span class="kw">let </span>byte = &amp; <span class="kw-2">mut </span><span class="self">self </span>. storage . as_mut () [byte_index] ; <span class="kw">let </span>bit_index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { <span class="number">7 </span>- (index % <span class="number">8</span>) } <span class="kw">else </span>{ index % <span class="number">8 </span>} ; <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; bit_index ; <span class="kw">if </span>val { * byte |= mask ; } <span class="kw">else </span>{ * byte &amp;= ! mask ; } } # [inline] <span class="kw">pub fn </span>get (&amp; <span class="self">self </span>, bit_offset : usize , bit_width : u8) -&gt; u64 { debug_assert ! (bit_width &lt;= <span class="number">64</span>) ; debug_assert ! (bit_offset / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width <span class="kw">as </span>usize)) / <span class="number">8 </span>&lt;= <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span><span class="kw-2">mut </span>val = <span class="number">0 </span>; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. (bit_width <span class="kw">as </span>usize) { <span class="kw">if </span><span class="self">self </span>. get_bit (i + bit_offset) { <span class="kw">let </span>index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { bit_width <span class="kw">as </span>usize - <span class="number">1 </span>- i } <span class="kw">else </span>{ i } ; val |= <span class="number">1 </span>&lt;&lt; index ; } } val } # [inline] <span class="kw">pub fn </span>set (&amp; <span class="kw-2">mut </span><span class="self">self </span>, bit_offset : usize , bit_width : u8 , val : u64) { debug_assert ! (bit_width &lt;= <span class="number">64</span>) ; debug_assert ! (bit_offset / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width <span class="kw">as </span>usize)) / <span class="number">8 </span>&lt;= <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. (bit_width <span class="kw">as </span>usize) { <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; i ; <span class="kw">let </span>val_bit_is_set = val &amp; mask == mask ; <span class="kw">let </span>index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { bit_width <span class="kw">as </span>usize - <span class="number">1 </span>- i } <span class="kw">else </span>{ i } ; <span class="self">self </span>. set_bit (index + bit_offset , val_bit_is_set) ; } } } # [repr (C)] # [derive (Default)] <span class="kw">pub struct </span>__IncompleteArrayField &lt; T &gt; (:: std :: marker :: PhantomData &lt; T &gt; , [T ; <span class="number">0</span>]) ; <span class="kw">impl </span>&lt; T &gt; __IncompleteArrayField &lt; T &gt; { # [inline] <span class="kw">pub const fn </span>new () -&gt; <span class="self">Self </span>{ __IncompleteArrayField (:: std :: marker :: PhantomData , []) } # [inline] <span class="kw">pub fn </span>as_ptr (&amp; <span class="self">self</span>) -&gt; * <span class="kw">const </span>T { <span class="self">self </span><span class="kw">as </span>* <span class="kw">const _ as </span>* <span class="kw">const </span>T } # [inline] <span class="kw">pub fn </span>as_mut_ptr (&amp; <span class="kw-2">mut </span><span class="self">self</span>) -&gt; * <span class="kw-2">mut </span>T { <span class="self">self </span><span class="kw">as </span>* <span class="kw-2">mut </span><span class="kw">_ as </span>* <span class="kw-2">mut </span>T } # [inline] <span class="kw">pub unsafe fn </span>as_slice (&amp; <span class="self">self </span>, len : usize) -&gt; &amp; [T] { :: std :: slice :: from_raw_parts (<span class="self">self </span>. as_ptr () , len) } # [inline] <span class="kw">pub unsafe fn </span>as_mut_slice (&amp; <span class="kw-2">mut </span><span class="self">self </span>, len : usize) -&gt; &amp; <span class="kw-2">mut </span>[T] { :: std :: slice :: from_raw_parts_mut (<span class="self">self </span>. as_mut_ptr () , len) } } <span class="kw">impl </span>&lt; T &gt; :: std :: fmt :: Debug <span class="kw">for </span>__IncompleteArrayField &lt; T &gt; { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, fmt : &amp; <span class="kw-2">mut </span>:: std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; :: std :: fmt :: <span class="prelude-ty">Result </span>{ fmt . write_str (<span class="string">"__IncompleteArrayField"</span>) } } # [repr (C)] # [derive (Debug)] <span class="kw">pub struct </span>vec &lt; T &gt; { <span class="kw">pub </span>sz : :: std :: os :: raw :: c_int , <span class="kw">pub </span>cap : :: std :: os :: raw :: c_int , <span class="kw">pub </span>data : * <span class="kw-2">mut </span>T , <span class="kw">pub </span>_phantom_0 : :: std :: marker :: PhantomData &lt; :: std :: cell :: UnsafeCell &lt; T &gt; &gt; , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>Tchar { <span class="kw">pub </span>v : :: std :: os :: raw :: c_char , } # [test] <span class="kw">fn </span>bindgen_test_layout_Tchar () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; Tchar &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; Tchar &gt; () , <span class="number">1usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Tchar))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Tchar &gt; () , <span class="number">1usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Tchar))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . v) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Tchar) , <span class="string">"::" </span>, stringify ! (v))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>Tint { <span class="kw">pub </span>v : :: std :: os :: raw :: c_int , } # [test] <span class="kw">fn </span>bindgen_test_layout_Tint () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; Tint &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; Tint &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Tint))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Tint &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Tint))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . v) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Tint) , <span class="string">"::" </span>, stringify ! (v))) ; } <span class="kw">pub const </span>VarBranch_VAR_DEFAULT : VarBranch = <span class="number">0 </span>; <span class="kw">pub const </span>VarBranch_VAR_INORDER : VarBranch = <span class="number">1 </span>; <span class="kw">pub const </span>VarBranch_VAR_SIZE_MIN : VarBranch = <span class="number">2 </span>; <span class="kw">pub const </span>VarBranch_VAR_SIZE_MAX : VarBranch = <span class="number">3 </span>; <span class="kw">pub const </span>VarBranch_VAR_MIN_MIN : VarBranch = <span class="number">4 </span>; <span class="kw">pub const </span>VarBranch_VAR_MIN_MAX : VarBranch = <span class="number">5 </span>; <span class="kw">pub const </span>VarBranch_VAR_MAX_MIN : VarBranch = <span class="number">6 </span>; <span class="kw">pub const </span>VarBranch_VAR_MAX_MAX : VarBranch = <span class="number">7 </span>; <span class="kw">pub const </span>VarBranch_VAR_DEGREE_MIN : VarBranch = <span class="number">8 </span>; <span class="kw">pub const </span>VarBranch_VAR_DEGREE_MAX : VarBranch = <span class="number">9 </span>; <span class="kw">pub const </span>VarBranch_VAR_REGRET_MIN_MAX : VarBranch = <span class="number">10 </span>; <span class="kw">pub const </span>VarBranch_VAR_REGRET_MAX_MAX : VarBranch = <span class="number">11 </span>; <span class="kw">pub const </span>VarBranch_VAR_REDUCED_COST : VarBranch = <span class="number">12 </span>; <span class="kw">pub const </span>VarBranch_VAR_PSEUDO_COST : VarBranch = <span class="number">13 </span>; <span class="kw">pub const </span>VarBranch_VAR_ACTIVITY : VarBranch = <span class="number">14 </span>; <span class="kw">pub const </span>VarBranch_VAR_RANDOM : VarBranch = <span class="number">15 </span>; <span class="kw">pub type </span>VarBranch = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>ValBranch_VAL_DEFAULT : ValBranch = <span class="number">0 </span>; <span class="kw">pub const </span>ValBranch_VAL_MIN : ValBranch = <span class="number">1 </span>; <span class="kw">pub const </span>ValBranch_VAL_MAX : ValBranch = <span class="number">2 </span>; <span class="kw">pub const </span>ValBranch_VAL_MIDDLE : ValBranch = <span class="number">3 </span>; <span class="kw">pub const </span>ValBranch_VAL_MEDIAN : ValBranch = <span class="number">4 </span>; <span class="kw">pub const </span>ValBranch_VAL_SPLIT_MIN : ValBranch = <span class="number">5 </span>; <span class="kw">pub const </span>ValBranch_VAL_SPLIT_MAX : ValBranch = <span class="number">6 </span>; <span class="kw">pub const </span>ValBranch_VAL_RANDOM : ValBranch = <span class="number">7 </span>; <span class="kw">pub type </span>ValBranch = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>DecInfo { <span class="kw">pub </span>var : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>val : :: std :: os :: raw :: c_int , <span class="kw">pub </span>type_ : :: std :: os :: raw :: c_int , } # [test] <span class="kw">fn </span>bindgen_test_layout_DecInfo () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; DecInfo &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; DecInfo &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (DecInfo))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; DecInfo &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (DecInfo))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . var) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (DecInfo) , <span class="string">"::" </span>, stringify ! (var))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . val) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (DecInfo) , <span class="string">"::" </span>, stringify ! (val))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . type_) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">12usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (DecInfo) , <span class="string">"::" </span>, stringify ! (type_))) ; } # [repr (C)] <span class="kw">pub struct </span>Branching__bindgen_vtable (:: std :: os :: raw :: c_void) ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>Branching { <span class="kw">pub </span>vtable_ : * <span class="kw">const </span>Branching__bindgen_vtable , } # [test] <span class="kw">fn </span>bindgen_test_layout_Branching () { assert_eq ! (:: std :: mem :: size_of :: &lt; Branching &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Branching))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Branching &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Branching))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z6branch3vecIP9BranchingE9VarBranch9ValBranch"</span>] <span class="kw">pub fn </span>branch (x : vec &lt; * <span class="kw-2">mut </span>Branching &gt; , var_branch : VarBranch , val_branch : ValBranch) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>Lit { <span class="kw">pub </span>x : :: std :: os :: raw :: c_int , } # [test] <span class="kw">fn </span>bindgen_test_layout_Lit () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; Lit &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; Lit &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Lit))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Lit &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Lit))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . x) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Lit) , <span class="string">"::" </span>, stringify ! (x))) ; } # [repr (C)] # [derive (Debug)] <span class="kw">pub struct </span>Clause { <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>data : __IncompleteArrayField &lt; Lit &gt; , } # [test] <span class="kw">fn </span>bindgen_test_layout_Clause () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; Clause &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; Clause &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Clause))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Clause &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Clause))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . data) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Clause) , <span class="string">"::" </span>, stringify ! (data))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZNK6Clause5debugEv"</span>] <span class="kw">pub fn </span>Clause_debug (this : * <span class="kw">const </span>Clause) ; } <span class="kw">impl </span>Clause { # [inline] <span class="kw">pub fn </span>learnt (&amp; <span class="self">self</span>) -&gt; :: std :: os :: raw :: c_uint { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_learnt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : :: std :: os :: raw :: c_uint) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>temp_expl (&amp; <span class="self">self</span>) -&gt; :: std :: os :: raw :: c_uint { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_temp_expl (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : :: std :: os :: raw :: c_uint) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>padding (&amp; <span class="self">self</span>) -&gt; :: std :: os :: raw :: c_uint { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">2usize </span>, <span class="number">6u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_padding (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : :: std :: os :: raw :: c_uint) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">2usize </span>, <span class="number">6u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>sz (&amp; <span class="self">self</span>) -&gt; :: std :: os :: raw :: c_uint { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">24u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_sz (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : :: std :: os :: raw :: c_uint) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">24u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (learnt : :: std :: os :: raw :: c_uint , temp_expl : :: std :: os :: raw :: c_uint , padding : :: std :: os :: raw :: c_uint , sz : :: std :: os :: raw :: c_uint) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>learnt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (learnt) } ; learnt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>temp_expl : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (temp_expl) } ; temp_expl <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">6u8 </span>, { <span class="kw">let </span>padding : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (padding) } ; padding <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">24u8 </span>, { <span class="kw">let </span>sz : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (sz) } ; sz <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } # [inline] <span class="kw">pub unsafe fn </span>debug (&amp; <span class="self">self</span>) { Clause_debug (<span class="self">self</span>) } } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>Reason { <span class="kw">pub </span>__bindgen_anon_1 : Reason__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>Reason__bindgen_ty_1 { <span class="kw">pub </span>pt : * <span class="kw-2">mut </span>Clause , <span class="kw">pub </span>d : Reason__bindgen_ty_1__bindgen_ty_1 , <span class="kw">pub </span>a : i64 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>Reason__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">8usize</span>] &gt; , } # [test] <span class="kw">fn </span>bindgen_test_layout_Reason__bindgen_ty_1__bindgen_ty_1 () { assert_eq ! (:: std :: mem :: size_of :: &lt; Reason__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Reason__bindgen_ty_1__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Reason__bindgen_ty_1__bindgen_ty_1 &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Reason__bindgen_ty_1__bindgen_ty_1))) ; } <span class="kw">impl </span>Reason__bindgen_ty_1__bindgen_ty_1 { # [inline] <span class="kw">pub fn </span>type_ (&amp; <span class="self">self</span>) -&gt; :: std :: os :: raw :: c_uint { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">2u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_type (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : :: std :: os :: raw :: c_uint) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">2u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>d1 (&amp; <span class="self">self</span>) -&gt; :: std :: os :: raw :: c_uint { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">2usize </span>, <span class="number">30u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_d1 (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : :: std :: os :: raw :: c_uint) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">2usize </span>, <span class="number">30u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>d2 (&amp; <span class="self">self</span>) -&gt; :: std :: os :: raw :: c_uint { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">32usize </span>, <span class="number">32u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_d2 (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : :: std :: os :: raw :: c_uint) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">32usize </span>, <span class="number">32u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (type_ : :: std :: os :: raw :: c_uint , d1 : :: std :: os :: raw :: c_uint , d2 : :: std :: os :: raw :: c_uint) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">8usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">8usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">2u8 </span>, { <span class="kw">let </span>type_ : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (type_) } ; type_ <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">30u8 </span>, { <span class="kw">let </span>d1 : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (d1) } ; d1 <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">32usize </span>, <span class="number">32u8 </span>, { <span class="kw">let </span>d2 : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (d2) } ; d2 <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [test] <span class="kw">fn </span>bindgen_test_layout_Reason__bindgen_ty_1 () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; Reason__bindgen_ty_1 &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; Reason__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Reason__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Reason__bindgen_ty_1 &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Reason__bindgen_ty_1))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . pt) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Reason__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (pt))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . d) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Reason__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (d))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . a) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Reason__bindgen_ty_1) , <span class="string">"::" </span>, stringify ! (a))) ; } # [test] <span class="kw">fn </span>bindgen_test_layout_Reason () { assert_eq ! (:: std :: mem :: size_of :: &lt; Reason &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Reason))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Reason &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Reason))) ; } <span class="kw">pub const </span>ConLevel_CL_DEF : ConLevel = <span class="number">0 </span>; <span class="kw">pub const </span>ConLevel_CL_VAL : ConLevel = <span class="number">1 </span>; <span class="kw">pub const </span>ConLevel_CL_BND : ConLevel = <span class="number">2 </span>; <span class="kw">pub const </span>ConLevel_CL_DOM : ConLevel = <span class="number">3 </span>; <span class="kw">pub type </span>ConLevel = :: std :: os :: raw :: c_uint ; # [repr (C)] <span class="kw">pub struct </span>Propagator__bindgen_vtable (:: std :: os :: raw :: c_void) ; # [repr (C)] # [derive (Debug)] <span class="kw">pub struct </span>Propagator { <span class="kw">pub </span>vtable_ : * <span class="kw">const </span>Propagator__bindgen_vtable , <span class="kw">pub </span>prop_id : :: std :: os :: raw :: c_int , <span class="kw">pub </span>priority : :: std :: os :: raw :: c_int , <span class="kw">pub </span>satisfied : Tchar , <span class="kw">pub </span>in_queue : bool , } # [test] <span class="kw">fn </span>bindgen_test_layout_Propagator () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; Propagator &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; Propagator &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Propagator))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Propagator &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Propagator))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . prop_id) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Propagator) , <span class="string">"::" </span>, stringify ! (prop_id))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . priority) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">12usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Propagator) , <span class="string">"::" </span>, stringify ! (priority))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . satisfied) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Propagator) , <span class="string">"::" </span>, stringify ! (satisfied))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . in_queue) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">17usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (Propagator) , <span class="string">"::" </span>, stringify ! (in_queue))) ; } <span class="kw">pub const </span>VarType_BOOL_VAR : VarType = <span class="number">0 </span>; <span class="kw">pub const </span>VarType_INT_VAR : VarType = <span class="number">1 </span>; <span class="kw">pub const </span>VarType_INT_VAR_EL : VarType = <span class="number">2 </span>; <span class="kw">pub const </span>VarType_INT_VAR_LL : VarType = <span class="number">3 </span>; <span class="kw">pub const </span>VarType_INT_VAR_SL : VarType = <span class="number">4 </span>; <span class="kw">pub type </span>VarType = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>PreferredVal_PV_MIN : PreferredVal = <span class="number">0 </span>; <span class="kw">pub const </span>PreferredVal_PV_MAX : PreferredVal = <span class="number">1 </span>; <span class="kw">pub const </span>PreferredVal_PV_SPLIT_MIN : PreferredVal = <span class="number">2 </span>; <span class="kw">pub const </span>PreferredVal_PV_SPLIT_MAX : PreferredVal = <span class="number">3 </span>; <span class="kw">pub const </span>PreferredVal_PV_MEDIAN : PreferredVal = <span class="number">4 </span>; <span class="kw">pub type </span>PreferredVal = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug)] <span class="kw">pub struct </span>Var { <span class="kw">pub </span>_base : Branching , } # [test] <span class="kw">fn </span>bindgen_test_layout_Var () { assert_eq ! (:: std :: mem :: size_of :: &lt; Var &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (Var))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; Var &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (Var))) ; } # [repr (C)] # [derive (Debug)] <span class="kw">pub struct </span>BoolView { <span class="kw">pub </span>_base : Var , <span class="kw">pub </span>v : :: std :: os :: raw :: c_int , <span class="kw">pub </span>s : bool , } # [test] <span class="kw">fn </span>bindgen_test_layout_BoolView () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; BoolView &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; BoolView &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (BoolView))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; BoolView &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (BoolView))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . v) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (BoolView) , <span class="string">"::" </span>, stringify ! (v))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . s) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">12usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (BoolView) , <span class="string">"::" </span>, stringify ! (s))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZNK8BoolView6attachEP10Propagatorii"</span>] <span class="kw">pub fn </span>BoolView_attach (this : * <span class="kw">const </span>BoolView , p : * <span class="kw-2">mut </span>Propagator , pos : :: std :: os :: raw :: c_int , eflags : :: std :: os :: raw :: c_int) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN8BoolView6detachEP10Propagatorii"</span>] <span class="kw">pub fn </span>BoolView_detach (this : * <span class="kw-2">mut </span>BoolView , p : * <span class="kw-2">mut </span>Propagator , pos : :: std :: os :: raw :: c_int , eflags : :: std :: os :: raw :: c_int) ; } <span class="kw">impl </span>BoolView { # [inline] <span class="kw">pub unsafe fn </span>attach (&amp; <span class="self">self </span>, p : * <span class="kw-2">mut </span>Propagator , pos : :: std :: os :: raw :: c_int , eflags : :: std :: os :: raw :: c_int) { BoolView_attach (<span class="self">self </span>, p , pos , eflags) } # [inline] <span class="kw">pub unsafe fn </span>detach (&amp; <span class="kw-2">mut </span><span class="self">self </span>, p : * <span class="kw-2">mut </span>Propagator , pos : :: std :: os :: raw :: c_int , eflags : :: std :: os :: raw :: c_int) { BoolView_detach (<span class="self">self </span>, p , pos , eflags) } } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN8BoolView8getScoreE9VarBranch"</span>] <span class="kw">pub fn </span>BoolView_getScore (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , vb : VarBranch) -&gt; f64 ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z8int_plusP6IntVarS0_S0_"</span>] <span class="kw">pub fn </span>int_plus (x : * <span class="kw-2">mut </span>IntVar , y : * <span class="kw-2">mut </span>IntVar , z : * <span class="kw-2">mut </span>IntVar) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z11output_varsR3vecIP9BranchingE"</span>] <span class="kw">pub fn </span>output_vars (v : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>Branching &gt;) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z11output_varsR3vecIP6IntVarE"</span>] <span class="kw">pub fn </span>output_vars1 (v : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt;) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z13all_differentR3vecIP6IntVarE8ConLevel"</span>] <span class="kw">pub fn </span>all_different (x : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt; , cl : ConLevel) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z13var_sym_breakR3vecIP6IntVarE"</span>] <span class="kw">pub fn </span>var_sym_break (x : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt;) ; } # [repr (C)] # [derive (Debug)] <span class="kw">pub struct </span>IntVar { <span class="kw">pub </span>_base : Var , <span class="kw">pub </span>var_id : :: std :: os :: raw :: c_int , <span class="kw">pub </span>min : Tint , <span class="kw">pub </span>max : Tint , <span class="kw">pub </span>min0 : :: std :: os :: raw :: c_int , <span class="kw">pub </span>max0 : :: std :: os :: raw :: c_int , <span class="kw">pub </span>shadow_val : :: std :: os :: raw :: c_int , <span class="kw">pub </span>in_scip : bool , <span class="kw">pub </span>all_in_scip : bool , <span class="kw">pub </span>should_be_learnable : bool , <span class="kw">pub </span>should_be_decidable : bool , <span class="kw">pub </span>vals : * <span class="kw-2">mut </span>Tchar , <span class="kw">pub </span>preferred_val : PreferredVal , <span class="kw">pub </span>activity : f64 , <span class="kw">pub </span>changes : :: std :: os :: raw :: c_int , <span class="kw">pub </span>in_queue : bool , <span class="kw">pub </span>pinfo : vec &lt; IntVar_PropInfo &gt; , <span class="kw">pub </span>sbps_value_selection : bool , <span class="kw">pub </span>last_solution_value : :: std :: os :: raw :: c_int , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>IntVar_PropInfo { <span class="kw">pub </span>p : * <span class="kw-2">mut </span>Propagator , <span class="kw">pub </span>pos : :: std :: os :: raw :: c_int , <span class="kw">pub </span>eflags : :: std :: os :: raw :: c_int , } # [test] <span class="kw">fn </span>bindgen_test_layout_IntVar_PropInfo () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; IntVar_PropInfo &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; IntVar_PropInfo &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (IntVar_PropInfo))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; IntVar_PropInfo &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (IntVar_PropInfo))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . p) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar_PropInfo) , <span class="string">"::" </span>, stringify ! (p))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . pos) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar_PropInfo) , <span class="string">"::" </span>, stringify ! (pos))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . eflags) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">12usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar_PropInfo) , <span class="string">"::" </span>, stringify ! (eflags))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>IntVar_iterator { <span class="kw">pub </span>var : * <span class="kw">const </span>IntVar , <span class="kw">pub </span>val : :: std :: os :: raw :: c_int , } # [test] <span class="kw">fn </span>bindgen_test_layout_IntVar_iterator () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; IntVar_iterator &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; IntVar_iterator &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (IntVar_iterator))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; IntVar_iterator &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (IntVar_iterator))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . var) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar_iterator) , <span class="string">"::" </span>, stringify ! (var))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . val) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar_iterator) , <span class="string">"::" </span>, stringify ! (val))) ; } <span class="kw">pub type </span>IntVar_const_iterator = IntVar_iterator ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>IntVar_reverse_iterator { <span class="kw">pub </span>forward : IntVar_iterator , } # [test] <span class="kw">fn </span>bindgen_test_layout_IntVar_reverse_iterator () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; IntVar_reverse_iterator &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; IntVar_reverse_iterator &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (IntVar_reverse_iterator))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; IntVar_reverse_iterator &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (IntVar_reverse_iterator))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . forward) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar_reverse_iterator) , <span class="string">"::" </span>, stringify ! (forward))) ; } <span class="kw">pub type </span>IntVar_const_reverse_iterator = IntVar_reverse_iterator ; <span class="kw">pub const </span>IntVar_max_limit : :: std :: os :: raw :: c_int = <span class="number">500000000 </span>; <span class="kw">pub const </span>IntVar_min_limit : :: std :: os :: raw :: c_int = - <span class="number">500000000 </span>; # [test] <span class="kw">fn </span>bindgen_test_layout_IntVar () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; IntVar &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; IntVar &gt; () , <span class="number">96usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (IntVar))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; IntVar &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (IntVar))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . var_id) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (var_id))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . min) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">12usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (min))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . max) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (max))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . min0) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">20usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (min0))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . max0) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (max0))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . shadow_val) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">28usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (shadow_val))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . in_scip) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (in_scip))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . all_in_scip) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">33usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (all_in_scip))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . should_be_learnable) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">34usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (should_be_learnable))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . should_be_decidable) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">35usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (should_be_decidable))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . vals) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (vals))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . preferred_val) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (preferred_val))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . activity) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">56usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (activity))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . changes) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">64usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (changes))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . in_queue) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">68usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (in_queue))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . pinfo) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">72usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (pinfo))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . sbps_value_selection) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">88usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (sbps_value_selection))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . last_solution_value) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">92usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (IntVar) , <span class="string">"::" </span>, stringify ! (last_solution_value))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar9updateMinEv"</span>] <span class="kw">pub fn </span>IntVar_updateMin (this : * <span class="kw-2">mut </span>IntVar) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar9updateMaxEv"</span>] <span class="kw">pub fn </span>IntVar_updateMax (this : * <span class="kw-2">mut </span>IntVar) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar11updateFixedEv"</span>] <span class="kw">pub fn </span>IntVar_updateFixed (this : * <span class="kw-2">mut </span>IntVar) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar15wakePropagatorsEv"</span>] <span class="kw">pub fn </span>IntVar_wakePropagators (this : * <span class="kw-2">mut </span>IntVar) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar15simplifyWatchesEv"</span>] <span class="kw">pub fn </span>IntVar_simplifyWatches (this : * <span class="kw-2">mut </span>IntVar) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar14specialiseToELEv"</span>] <span class="kw">pub fn </span>IntVar_specialiseToEL (this : * <span class="kw-2">mut </span>IntVar) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar14specialiseToLLEv"</span>] <span class="kw">pub fn </span>IntVar_specialiseToLL (this : * <span class="kw-2">mut </span>IntVar) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar14specialiseToSLER3vecIiE"</span>] <span class="kw">pub fn </span>IntVar_specialiseToSL (this : * <span class="kw-2">mut </span>IntVar , values : * <span class="kw-2">mut </span>vec &lt; :: std :: os :: raw :: c_int &gt;) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar8initValsEb"</span>] <span class="kw">pub fn </span>IntVar_initVals (this : * <span class="kw-2">mut </span>IntVar , optional : bool) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVarC1Eii"</span>] <span class="kw">pub fn </span>IntVar_IntVar (this : * <span class="kw-2">mut </span>IntVar , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int) ; } <span class="kw">impl </span>IntVar { # [inline] <span class="kw">pub unsafe fn </span>updateMin (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { IntVar_updateMin (<span class="self">self</span>) } # [inline] <span class="kw">pub unsafe fn </span>updateMax (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { IntVar_updateMax (<span class="self">self</span>) } # [inline] <span class="kw">pub unsafe fn </span>updateFixed (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { IntVar_updateFixed (<span class="self">self</span>) } # [inline] <span class="kw">pub unsafe fn </span>wakePropagators (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { IntVar_wakePropagators (<span class="self">self</span>) } # [inline] <span class="kw">pub unsafe fn </span>simplifyWatches (&amp; <span class="kw-2">mut </span><span class="self">self</span>) -&gt; :: std :: os :: raw :: c_int { IntVar_simplifyWatches (<span class="self">self</span>) } # [inline] <span class="kw">pub unsafe fn </span>specialiseToEL (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { IntVar_specialiseToEL (<span class="self">self</span>) } # [inline] <span class="kw">pub unsafe fn </span>specialiseToLL (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { IntVar_specialiseToLL (<span class="self">self</span>) } # [inline] <span class="kw">pub unsafe fn </span>specialiseToSL (&amp; <span class="kw-2">mut </span><span class="self">self </span>, values : * <span class="kw-2">mut </span>vec &lt; :: std :: os :: raw :: c_int &gt;) { IntVar_specialiseToSL (<span class="self">self </span>, values) } # [inline] <span class="kw">pub unsafe fn </span>initVals (&amp; <span class="kw-2">mut </span><span class="self">self </span>, optional : bool) { IntVar_initVals (<span class="self">self </span>, optional) } # [inline] <span class="kw">pub unsafe fn </span>new (min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int) -&gt; <span class="self">Self </span>{ <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_tmp = :: std :: mem :: MaybeUninit :: uninit () ; IntVar_IntVar (__bindgen_tmp . as_mut_ptr () , min , max) ; __bindgen_tmp . assume_init () } } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar6attachEP10Propagatorii"</span>] <span class="kw">pub fn </span>IntVar_attach (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , p : * <span class="kw-2">mut </span>Propagator , pos : :: std :: os :: raw :: c_int , eflags : :: std :: os :: raw :: c_int) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar8getScoreE9VarBranch"</span>] <span class="kw">pub fn </span>IntVar_getScore (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , vb : VarBranch) -&gt; f64 ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar6branchEv"</span>] <span class="kw">pub fn </span>IntVar_branch (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>DecInfo ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar6setMinEl6Reasonb"</span>] <span class="kw">pub fn </span>IntVar_setMin (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , v : i64 , r : Reason , channel : bool) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar6setMaxEl6Reasonb"</span>] <span class="kw">pub fn </span>IntVar_setMax (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , v : i64 , r : Reason , channel : bool) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar6setValEl6Reasonb"</span>] <span class="kw">pub fn </span>IntVar_setVal (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , v : i64 , r : Reason , channel : bool) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar6remValEl6Reasonb"</span>] <span class="kw">pub fn </span>IntVar_remVal (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , v : i64 , r : Reason , channel : bool) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_ZN6IntVar8allowSetER3vecIiE6Reasonb"</span>] <span class="kw">pub fn </span>IntVar_allowSet (this : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , v : * <span class="kw-2">mut </span>vec &lt; :: std :: os :: raw :: c_int &gt; , r : Reason , channel : bool) -&gt; bool ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z9createVarRP6IntVariib"</span>] <span class="kw">pub fn </span>createVar (x : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>IntVar , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , el : bool) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z10createVarsR3vecIP6IntVarEiiib"</span>] <span class="kw">pub fn </span>createVars (x : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt; , n : :: std :: os :: raw :: c_int , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , el : bool) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z10createVarsR3vecIS_IP6IntVarEEiiiib"</span>] <span class="kw">pub fn </span>createVars1 (x : * <span class="kw-2">mut </span>vec &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; , n : :: std :: os :: raw :: c_int , m : :: std :: os :: raw :: c_int , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , el : bool) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z10createVarsR3vecI8BoolViewEi"</span>] <span class="kw">pub fn </span>createVars2 (x : * <span class="kw-2">mut </span>vec &lt; BoolView &gt; , n : :: std :: os :: raw :: c_int) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z10createVarsR3vecIS_I8BoolViewEEii"</span>] <span class="kw">pub fn </span>createVars3 (x : * <span class="kw-2">mut </span>vec &lt; vec &lt; BoolView &gt; &gt; , n : :: std :: os :: raw :: c_int , m : :: std :: os :: raw :: c_int) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>DummyProblem { <span class="kw">pub </span>searchVars : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt; , <span class="kw">pub </span>callback : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt;) &gt; , } # [test] <span class="kw">fn </span>bindgen_test_layout_DummyProblem () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; DummyProblem &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; DummyProblem &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of: " </span>, stringify ! (DummyProblem))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; DummyProblem &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of " </span>, stringify ! (DummyProblem))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . searchVars) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (DummyProblem) , <span class="string">"::" </span>, stringify ! (searchVars))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . callback) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">"Offset of field: " </span>, stringify ! (DummyProblem) , <span class="string">"::" </span>, stringify ! (callback))) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z17new_dummy_problemv"</span>] <span class="kw">pub fn </span>new_dummy_problem () -&gt; * <span class="kw-2">mut </span>DummyProblem ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z9p_addVarsP12DummyProblemP3vecIP6IntVarE"</span>] <span class="kw">pub fn </span>p_addVars (p : * <span class="kw-2">mut </span>DummyProblem , _searchVars : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt;) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z13p_setcallbackP12DummyProblemPFvP3vecIP6IntVarEE"</span>] <span class="kw">pub fn </span>p_setcallback (p : * <span class="kw-2">mut </span>DummyProblem , _callback : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt;) &gt;) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z7p_printP12DummyProblem"</span>] <span class="kw">pub fn </span>p_print (p : * <span class="kw-2">mut </span>DummyProblem) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z7get_idxP3vecIP6IntVarEi"</span>] <span class="kw">pub fn </span>get_idx (x : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt; , i : :: std :: os :: raw :: c_int) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z15make_vec_intvarv"</span>] <span class="kw">pub fn </span>make_vec_intvar () -&gt; * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt; ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z18destroy_vec_intvarP3vecIP6IntVarE"</span>] <span class="kw">pub fn </span>destroy_vec_intvar (v : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt;) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z13branch_IntVarP3vecIP6IntVarE9VarBranch9ValBranch"</span>] <span class="kw">pub fn </span>branch_IntVar (x : * <span class="kw-2">mut </span>vec &lt; * <span class="kw-2">mut </span>IntVar &gt; , var_branch : VarBranch , val_branch : ValBranch) ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z15new_xyz_problemi"</span>] <span class="kw">pub fn </span>new_xyz_problem (n : :: std :: os :: raw :: c_int) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">"C" </span>{ # [link_name = <span class="string">"\u{1}_Z9solve_xyzPv"</span>] <span class="kw">pub fn </span>solve_xyz (p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_Branching_close0_instantiation () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>Branching &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>Branching &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>Branching &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>Branching &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_Branching_close0_instantiation_1 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>Branching &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>Branching &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>Branching &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>Branching &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_1 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_2 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_IntVar_PropInfo_close0_instantiation () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; IntVar_PropInfo &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; IntVar_PropInfo &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; IntVar_PropInfo &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; IntVar_PropInfo &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_int_close0_instantiation () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; :: std :: os :: raw :: c_int &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; :: std :: os :: raw :: c_int &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; :: std :: os :: raw :: c_int &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; :: std :: os :: raw :: c_int &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_int_close0_instantiation_1 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; :: std :: os :: raw :: c_int &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; :: std :: os :: raw :: c_int &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; :: std :: os :: raw :: c_int &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; :: std :: os :: raw :: c_int &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_3 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_4 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_BoolView_close0_instantiation () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; BoolView &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; BoolView &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; BoolView &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; BoolView &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_BoolView_close0_instantiation_1 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; BoolView &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; BoolView &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; BoolView &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; BoolView &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_5 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_6 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_7 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_8 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_9 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_10 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_11 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; } # [test] <span class="kw">fn </span>__bindgen_test_layout_vec_open0_ptr_IntVar_close0_instantiation_12 () { assert_eq ! (:: std :: mem :: size_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">"Size of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; vec &lt; * <span class="kw-2">mut </span>IntVar &gt; &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">"Alignment of template specialization: " </span>, stringify ! (vec &lt; * <span class="kw-2">mut </span>IntVar &gt;))) ; }</code></pre></div></section></main></body></html>